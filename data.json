{
	"courses" : [
		{
			"Name" : "Automated Reasoning",
			"Code" : "INFR09042",
			"CourseSummary" : "The overall aim of the course is to describe how reasoning can be modelled using computers. Its more specific aim is to provide a route into more advanced uses of theorem proving in order to solve problems in mathematics and formal verification.Major emphases are on: how knowledge can be represented using propositional, first-order and higher-order logic; how these representations can be used as the basis for reasoning, and how these reasoning processes can be guided to a successful conclusion through a variety of means ranging from fully-automated to interactive ones. Students will develop a thorough understanding of modern, interactive theorem proving via lectures, tutorials and an assignment. ",
			"CourseDescription" : "The course starts with an introduction to higher order logic, theorem provers and, more specifically, Isabelle/HOL. This will set the context for the rest of the course in which Isabelle will be the framework for getting hands-on experience about the application of various theoretical concepts.Through the lectures and tutorials that incorporate practical exercises the students will gain the skills needed to get started with Isabelle and progress to more complex concepts involving both representation and reasoning.The second part will look at representation/modelling of concepts in (higher order) logic in details. Axiomatic versus conservative extensions of theories will be covered and mechanisms such as Isabelle locales will be introduced and used. Recursive definitions and inductive notions will be covered too.The third part of the course will focus on fundamental notions such as unification and rewriting, within both a first and higher order context. It will look at notions such as termination and use Isabelle's simplifier as the tool for understanding many of the concepts. It will also look at the interplay between (fully) automatic and interactive proofs.The fourth part will introduce declarative/structured proofs and using the Isar language of Isabelle show how proofs resembling pencil and paper ones can be formalized.Finally the various strands will brought together through the discussion of a non-trivial case study.This may involve either formalized mathematics (e.g. looking at a geometric theory) or a formal verification example.The assignment will be a combination of basic to intermediate representation and reasoning in Isabelle (up to 40%), more advanced proof tackling one particular domain or example (up to 40%) and a final part which, if completed successfully, will clearly demonstrate that the student has a good of the challenges that advanced interactive theorem proving entails.",
			"Credits" : "10",
			"Level" : "09",
			"Year" : "3",
			"Average" : "60.15",
			"Area" : "Artificial Intelligence",
			"Prerequisites" : [],
			"Feedback" : ["I would recommend it, as long as you're prepared to sit down and spend some time making sure you know how to use Isabelle",
						  "IT'S A PAINFUL COURSE, DON'T DO IT UNLESS YOU REALLY LIKE ASSISTED THEOREM PROVING AND LOGIC",
						  "This course will be painful, if you are not interested in Logic, Math and programming. Honestly, don't take it, unless you are interested in those three. However, if you are, this is possibly the best course for you.",
						  "Work constantly on the material as its being taught and make sure you understand and try to solve all the tutorial questions. That way you will not find any problem dealing with the course. Otherwise you might struggle with it, especially with the coursework",
						  "Worth the challenge."]
		},
		{
			"Name" : "Computer Design",
			"Code" : "INFR09046",
			"CourseSummary" : "This course provides an introduction to the fundamental concepts of the different ways computers can be analysed and designed. The course does not look at the differences between machines with different types of instruction set, nor does it cover design techniques for extracting maximum performance from computers - these aspects of computer hardware are covered in the Computer Architecture course. The issues and techniques covered in the Computer Design course are relevant to the design of all computers, regardless of their particular architecture.The course is partitioned into three sections. The short first section revises the design of combinational and sequential logic. The second section demonstrates how to analyse and design systems of the complexity of a simple CPU or I/O controller. The third section of the course covers the design of a complete computer capable of executing assembly code programs and different control strategies for performing I/O.",
			"CourseDescription" : "Logic Design Revision Simple combinational logic design to state machines for sequential circuits.Processor Design Data path and control. Fixed program controllers: example and design procedure. Instruction set processors: data path design, simple control, microprogrammed control. ALU design: addition, ripple carry and look ahead adders, negative numbers & subtraction; multiplication sequential multiplier, modification for 2's complement, combinational multiplier, division. Floating point numbers: addition, multiply and divide, implementations.Computer Systems Memory: Byte vs. word addressing, memory system design, error detection and correction. I/O Design: I/O controller design. Connection of I/O controllers to CPU, synchronization of I/O and CPU, polling, interrupts. Direct Memory Access, bus arbitration, DMA controller implementation. I/O processors. Synchronous and asynchronous buses. Simple performance enhancements to the basic architecture. RISC.",
			"Credits" : "20",
			"Level" : "09",
			"Year" : "3",
			"Average" : "77.63",
			"Area" : "Architecture",
			"Prerequisites" : [],
			"Feedback" : ["Content was interesting and the coursework was a great way to enhance the overall understanding of the study material. The exercise sheets and provided answers were also very helpful, since they gave an idea of potential exam questions. The lecturer is very good at explaining the content and was really helpful during labs - sometimes stayed well beyond the lab finish time to help us with the coursework. Overall, a really good course and one of the best lecturers I have had at uni so far",
						  "Excellent lecturer, very clear and explained things extremely well, both in lectures and tutorials. Interesting and engaging course."]
		},
		{
			"Name" : "Foundations of Natural Language Processing",
			"Code" : "INFR09028",
			"CourseSummary" : "This course covers some of the linguistic and algorithmic foundations of natural language processing. It builds on the material introduced in Informatics 2A and aims to equip students for more advanced NLP courses in years 3 or 4. The course is strongly empirical, using corpus data to illustrate both core linguistic concepts and algorithms, including language modeling, part of speech tagging, syntactic processing, the syntax-semantics interface, and aspects of semantic processing. Linguistic and algorithmic content will be interleaved throughout the course.",
			"CourseDescription" : "1. Creating annotated corpora:* markup, annotation* evaluation measures* corpora and the web 2. Lexicon and lexical processing:* language modeling* Hidden Markov Models* part of speech tagging (e.g., for a language other than English) to illustrate HMMs* Viterbi algorithm* smoothing 3. Syntax and syntactic processing:* syntactic concepts: constituency, subcategorization, bounded and unbounded dependencies, feature representations4. Semantics and semantic processing:* compositionality, * argument structure, * word sense disambigution,  * anaphora resolution, * treebanks: argument structure, WSD (e.g., Propbank, Semcor)Relevant QAA Computing Curriculum Sections: Artificial Intelligence, Natural Language Computing",
			"Credits" : "10",
			"Level" : "09",
			"Year" : "3",
			"Average" : "81.52",
			"Area" : "Artificial Intelligence",
			"Prerequisites" : [],
			"Feedback" : ["It’s a very easy course but essential to your development as a Computer Scientist. You will understand everything even better if you also take IAML",
						  "This course is excellent, take it and enjoy it. The workload is pretty fair in my opinion and the assignments are posted well in advance. Go to the lectures, they are both useful and really engaging.",
						  "This course taught you foundations about NLP, very good introductory course.",
						  "Lectures are great, but don't teach you how to code the assignments at all. That's expected, but the lab leaders also did not help with coding very much, so unless you know Python very well already the assignments were difficult.",
						  "Take it. It’s great."]
		},
		{
			"Name" : "Introduction to Vision and Robotics",
			"Code" : "INFR09019",
			"CourseSummary" : "Robotics and Vision applies AI techniques to the problems of making devices capable of interacting with the physical world. This includes moving around in the world (mobile robotics), moving things in the world (manipulation robotics), acquiring information by direct sensing of the world (e.g. machine vision) and, importantly, closing the loop by using sensing to control movement. Applying AI in this context poses certain problems, and sets certain limitations, which have important effects on the general software and hardware architectures. For example, a robot with legs must be able to correct detected imbalances before it falls over, and a robot which has to look left and right before crossing the road must be able to identify approaching hazards before it gets run over. These constraints become much more serious if the robot is required to carry both its own power supply and its own brain along with it. This module introduces the basic concepts and methods in these areas, and serves as an introduction to the more advanced robotics and vision modules.",
			"CourseDescription" : "The issues addressed will include the following: * Applications of robotics and vision; the nature of the problems to be solved; historical overview and current state of the art. * Robot actuators and sensors. Parallels to biological systems. * Robot control: Open-loop, feed-forward and feedback; PID (proportional integral differential) control. * Image formation, transduction and simple processing; thresholding, filtering and classification methods for extracting object information from an image. * Active vision and attention. * Sensors for self monitoring. * General approaches and architectures. Classical vs. behaviour-based robotics. Wider issues and implications of robot research.  The course also involves hands-on practicals in which vision and robot systems will be programmed. Relevant QAA Computing Curriculum Sections: Artificial Intelligence; Computer Vision and Image Processing",
			"Credits" : "10",
			"Level" : "09",
			"Year" : "3",
			"Average" : "63.65",
			"Area" : "Artificial Intelligence",
			"Prerequisites" : [],
			"Feedback": [" Don't. If you're unlucky enough to have signed up for this course, drop it as soon as you can. You'll do better and learn more if you jump into any other course half way through the semester.",
						 "START THE COURSEWORK EARLY!!!!",
						 "Take this course only if you have decent maths and physics",
						 "Take your time to go through the equations on the slides and make sure you understand them. It is too late to start paying attention to them once you start working on the coursework.",
						 "Focus on the Labs for this course, which are helpful for both lectures and assignment."]
		},
		{
			"Name" : "Operating Systems",
			"Code" : "INFR09047",
			"CourseSummary" : "This course provides an introduction to the design and implementation of general purpose multi-tasking operating systems. It concentrates on the kernel aspects of such systems with the emphasis being on concepts which lead to practical implementations. Throughout the course reference is made to a number of significant actual operating systems (Linux, Windows variants etc.) to illustrate real implementations.",
			"CourseDescription" : "Process management*The process concept, synchronisation, mutual exclusion, semaphores and monitors. Threads. Inter-process communication.Resource Allocation*Deadlock prevention, avoidance and detection.The OS Kernel*Micro and Monolithic kernels. Multi-tasking, privilege, interrupt handling. System and user processes. System calls.Memory Management*Description of problems of allocation, protection and sharing. Virtual Physical memory mapping schemes.*Segmented paged virtual memory. Paging control, replacement algorithms; the working set model. Sharing code and data. Time ManagementFile Management*Naming and Directory schemes. Disc space allocation. File protection and access control. System security. *Various additional topics may be included from year to year. Relevant QAA Computing Curriculum Sections: Operating Systems",
			"Credits" : "20",
			"Level" : "09",
			"Year" : "3",
			"Average" : "71.63",
			"Area" : "Architecture",
			"Prerequisites" : [],
			"Feedback" : ["Go for it, both the lectures and the coursework are quite enjoyable. Make sure you read the coursework assignments while well rested. It is somewhat difficult to understand at first but once you do, the implementation is reasonably straightforward.",
						  "It's easy to follow and understand.",
						  "Quite interesting and very good lecturers!",
						  "Recommended.",
						  "Start the assignments early."]
		},
		{
			"Name" : "System Design Project",
			"Code" : "INFR09032",
			"CourseSummary" : "The System Design Project is intended to give students practical experience of (a) building a large scale system (b) working as members of a team. The project involves applying and combining material from several courses to complete a complex design and implementation task. At the end of course each group demonstrates its implemented system and gives a formal presentation to an audience of the students, supervisors, and visitors from industry.",
			"CourseDescription" : "During this project students work in groups of about ten on the design and implementation of a complete system to solve some practical and useful problem. All groups perform the same task. This primarily involves software implementation but may potentially also involve hardware design and construction where this is relevant. Recent examples of projects include: an automated on-line supermarket; building webcam-based home and commercial security systems; constructing Mars and Lunar rovers controlled from an Earth-based web browser interface, etc.Each group is provided with the same facilities. These include one or more PCs dedicated to them and other equipment depending on the particular project, for instance a webcam, a Lego robot construction kit, hardware prototyping kit, diagnostic equipment etc. They also have a small amount of money to spend in any way they choose on any extra items they feel might enhance their particular design. Project management software is also available to them. Each group is assigned a mentor. The mentor's task is to advise and provide feedback on the progress of the group during the project but not to provide technical support. Consultants from amongst the academic and support staff are made available to advise on aspects of the task such as management, specific pieces of software and hardware etc. Groups meet with their mentors at least once a week. They also meet amongst themselves more frequently to plan and coordinate their activities. Towards the end of the semester, a day is set aside for groups to demonstrate their implemented system and to give a formal presentation of it to an audience of the students, mentors, and visitors from industry. Relevant QAA Computing Curriculum Sections: Computer Based Systems, Systems Analysis and Design",
			"Credits" : "20",
			"Level" : "09",
			"Year" : "3",
			"Average" : "71.09",
			"Area" : "Artificial Intelligence",
			"Prerequisites" : [],
			"Feedback" : ["I am really sorry for you! Hope it ends well! Pray for a team with decent people!",
						  "Do not take this course. It is one of the worst-run and most stressful courses in Informatics.",
						  "Although it’s an Informatics course, be prepared to do a lot of work in terms of organization, team management, writing documentation and etc. Useful if you don't have any industry experience. However, if you have experience and it's not compulsory for you, think twice before taking this course (its loads of work)",
						  "Find good ways of dealing with stress because this course will be a lot of stress."]
		},
		{
			"Name" : "Algorithms and Data Structures",
			"Code" : "INFR10052",
			"CourseSummary" : "The course aims to provide general techniques for the design of efficient algorithms and, in parallel, develop appropriate mathematical tools for analysing their performance. In this, it broadens and deepens the study of algorithms and data structures initiated in INF2. The focus is on algorithms, more than data structures. Along the way, problem solving skills are exercised and developed.",
			"CourseDescription" : "Introductory concepts. Review of CS2. Models of computation; time and space complexity; upper and lower bounds, big-O and big-Omega notation; average and worst case analysis. Divide and conquer. Matrix multiplication: Strassen's algorithm; the discrete Fourier transform (DFT), the fast Fourier transform (FFT). Expressing the runtime of a recursive algorithm as a recurrence relation; solving recurrence relations. Sorting. Quicksort and its analysis; worst-case, best-case and average-case. Data structures: Disjoint sets. The ``disjoint sets'' (union-find) abstract data type: specification and implementations as lists and trees. Union-by-rank, path-compression, etc., ``heuristics''. Applications to finding minimum spanning trees. Dynamic programming. Introduction to the technique; examples: Matrix-chain multiplication, Longest common subsequences. Graph/Network algorithms Network flow, Max-flow/min-cut theorem, Ford-Fulkerson algorithm. Geometric algorithms Convex hull of a set of points (in 2-d). Relevant QAA Computing Curriculum Sections: Data Structures and Algorithms",
			"Credits" : "10",
			"Level" : "10",
			"Year" : "3",
			"Average" : "72.26",
			"Area" : "Algorithms and Data Structures",
			"Prerequisites" : [],
			"Feedback" : ["Attend all lectures and tutorials because it is WORTH IT",
						  "Do not take this course",
						  "Don't go to lectures. Read the book instead.",
						  "Prepare for boring lectures haha",
						  "The course is hard if you do not like proofs, but I found it really interesting and I learnt some new algorithms. It is really useful if you want to improve your algorithmic knowledge, but be prepared to be challenged. Bear in mind that you mind have to do some individual studying to actually understand."]
		},
		{
			"Name" : "Computational Cognitive Science",
			"Code" : "INFR10054",
			"CourseSummary" : "This course aims to introduce students to the basic concepts and methodology needed to implement and analyse computational models of cognition. It considers the fundamental issues of using a computational approach to explore and model cognition. In particular, we explore the way that computational models relate to, are tested against, and illuminate psychological theories and data. The course will introduce both symbolic and subsymbolic modelling methodologies, and provide practical experience with implementing models. The symbolic part will focus on cognitive architectures,while the subsymbolic part will introduce probabilistic models.",
			"CourseDescription" : "This course aims to introduce students to the basic concepts and methodology needed to implement and analyse computational models of cognition. It considers the fundamental issues of using a computational approach to explore and model cognition. In particular, we explore the way that computational models relate to, are tested against, and illuminate psychological theories and data. The course will introduce both symbolic and subsymbolic modelling methodologies, and provide practical experience with implementing models. The symbolic part will focus on cognitive architectures,while the subsymbolic part will introduce probabilistic models.",
			"Credits" : "10",
			"Level" : "10",
			"Year" : "3",
			"Average" : "58.80",
			"Area" : "Artificial Intelligence",
			"Prerequisites" : [],
			"Feedback" : ["Don't skip the lectures, can be difficult to catch up from just the slides.",
						  "It is a challenging yet very nice introduction to the area. Warning: There is a lot of probabilistic theories/concepts/thinking involved, turning theories from psychology into computational models is assumption- and maths-heavy :-)",
						  "Refresh your probability and calculus knowledge before starting this course! It's a fairly gentle course if you keep up with the lectures and tutorials and the recommended textbook is fantastic for supplementing these.",
						  "Be prepared that this course is rather challenging but do not be scared to actually open up because once you're through the worst bit it actually all starts making sense."]
		},
		{
			"Name" : "Computer Communications and Networks",
			"Code" : "INFR10074",
			"CourseSummary" : "This is a comprehensive first course in Computer Communications and Networks, focusing on fundamental concepts, principles and techniques. The course will introduce basic networking concepts, including: protocol, network architecture, reference models, layering, service, interface, multiplexing, switching and standards. An overview of digital communication from the perspective of computer networking will also be provided. Topics covered in this course include: Internet (TCP/IP) architecture and protocols, network applications, congestion/flow/error control, routing and internetworking, data link protocols, error detection and correction, channel allocation and multiple access protocols, communication media and selected topics in wireless and data centre networks. It will cover recent advances in network control and management architectures by introducing the concepts of software-defined networking (SDN) and network (function) virtualisation. Students taking this course will gain hands-on experience in network programming using the socket API; network traffic/protocol analysis; and on assessment of alternative networked systems and architectures.",
			"CourseDescription" : "* Introduction to Computer Networking and the Internet * Digital Communication Basics * The Application Layer with comprehensive treatment of networked applications (incl. multimedia data and applications) * The Transport Layer * The Network Layer * The Data Link Layer * The Medium Access Control Sub-Layer * The Physical Layer * Software-defined networking (SDN) * Network virtualisation and network function virtualisation (NFV) * Network management * Introduction to data centre and wireless networks * Overview and selected aspects of network security",
			"Credits" : "20",
			"Level" : "10",
			"Year" : "3",
			"Average" : "70.58",
			"Area" : "Networks",
			"Prerequisites" : [],
			"Feedback" : ["It is an interesting course but it is full of theory. A lot of material to learn",
						  "The second coursework is a lot harder than the first and worth a lot more, so keep that in mind.",
						  "Very interesting if keen to learn about networks. Not very demanding but do attend the lectures, you miss a lot of information and tips if you don't",
						  "This course teaches very helpful material"]
		},
		{
			"Name" : "Computer Security",
			"Code" : "INFR10067",
			"CourseSummary" : "Computer Security is concerned with the protection of computer systems and their data from threats which may compromise integrity, availability, or confidentiality; the focus is on threats of a malicious nature rather than accidental. This course aims to give a broad understanding of computer security. Topics include security risks, attacks, prevention and defence methods; techniques for writing secure programs; an overview of the foundations for cryptography, security protocols and access control models. ",
			"CourseDescription" : "The goal of this course is to introduce students to fundamental security concepts and offer them working knowledge of threats and counter-measures. The topics covered in the course are: ¿ Introduction: fundamental concepts, access control models, threat modelling. ¿ Network security: basic networking concepts, DoS, Transport layer security, Link layer security, DNS attacks, Firewalls, Intrusion detection. ¿ Usable security: basic human factors, warning design, phishing, authentication, device authentication. ¿ Cryptography: symmetric ciphers, asymmetric ciphers, MACs and hash functions, digital signatures. ¿ Cryptographic protocols: identification, authentication and key agreement, SSL/TLS, anonymity protocols, TOR. ¿ OS security: OS concepts, memory and file system, access control, file permissions, memory safety, stack-based buffer overflows. ¿ Malware: viruses, trojan horses, worms, rootkits. ¿ Web security: WWW basics, client-side attacks, session hijacking XSS, CSRF, defences, server-side attacks, SQL injection, RFI, LFI.",
			"Credits" : "20",
			"Level" : "10",
			"Year" : "3",
			"Average" : "70.87",
			"Area" : "Security and Cryptography",
			"Prerequisites" : [],
			"Feedback" : ["Attend all the lectures as they are very informative.",
						  "Be prepared to be intellectually challenged and do the readings before each lecture otherwise you will understand only half of it.",
						  "It is not an easy course. It is important to do the reading.",
						  "It's a fun and good course, but be prepared to study a lot of cryptography and discrete",
						  "Quite challenging but really fun, would recommend",
						  "It will be challenging but rewarding, prepare to work hard and feel proud at the end"]
		},
		{
			"Name" : "Database Systems",
			"Code" : "INFR10070",
			"CourseSummary" : "Databases are essential to maintaining the information base in almost all modern business enterprises and to electronic commerce. They are also becoming increasingly important as a fundamental tool in much scientific research. Some knowledge of databases is now essential in any of these areas. The study of databases draws on several disciplines within computer science: logic, algorithms, programming languages and operating systems. This course is an introduction to the principles underlying the design and implementation of databases and database management systems. It will cover the theoretical and practical languages that have been developed for relational databases, their implementation and optimisation. It will also cover transaction processing and concurrency control, as well as tools and techniques for decision support and data analysis. In addition, some recent developments in databases, including semistructured data and the relationship between relational databases and XML documents, will be introduced.",
			"CourseDescription" : "- Overview of database management systems and the relational model - Database design: E-R diagrams, constraints, normal forms - Query languages: relational algebra and calculus - Database access from applications: embedded and dynamic SQL - Storage and indexing: B-trees, hashing - Query evaluation and optimisation: join strategies, query plans - Scheduling and concurrency control: transaction management, serializability, locking - Data warehousing and decision support: OLAP, view materialisation and maintenance - Deductive databases: Datalog and recursive queries - Incomplete data: null values and certain answers - Semistructured data: XML documents, DTDs, query languages for XML",
			"Credits" : "20",
			"Level" : "10",
			"Year" : "3",
			"Average" : "68.56",
			"Area" : "Databases",
			"Prerequisites" : [],
			"Feedback" : ["Do take it if you're interested in databases and want to learn SQL. You'll learn both so make sure you're comfortable with learning the theory behind databases.",
						  "Go for it, especially if you finally understood Computational Logic at the end of first semester first year and if you enjoyed INF2D -Agents and Reasoning",
						  "It's a really good course if you don't know much about SQL. If you already know plenty, it might not be able to teach you a lot.",
						  "Would recommend; workload is reasonable and at a good level",
						  "Continuously study, ask for help as soon as you need it and don't wait, and start early on the homework."]
		},
		{
			"Name" : "Compiling Techniques",
			"Code" : "INFR10065",
			"CourseSummary" : "This course describes the phases of a modern programming language compiler with an emphasis on widely-used techniques. The course project will require students to implement a complete compiler from scratch for a simple programming language, targeting a real machine assembly such as MIPS. Students will also learn about implementing a compiler pass in a real compiler framework. ",
			"CourseDescription" : "* Introduction: structure of a compiler * Lexical analysis: tokens, regular expressions, Lex * Parsing: context-free grammars, predictive and LR parsing * Abstract syntax: semantic actions, abstract parse trees * Semantic analysis: symbol tables, bindings, type-checking * Stack frames: representation and abstraction * Intermediate code: representation trees, translation * Basic blocks and traces: canonical trees and conditional branches * Instruction selection: algorithms for selection, RISC and CISC * Liveness analysis: solution of dataflow equations * Register allocation: colouring by simplification, coalescing * Real assembly language: ARM or MIPS * Advanced Topics may include: automatic parallelisation, popular open-source compilers: GCC, LLVM ",
			"Credits" : "20",
			"Level" : "10",
			"Year" : "3",
			"Average" : "78.95",
			"Area" : "Programming Language",
			"Prerequisites" : [],
			"Feedback" : ["Be prepared to work a lot and work hard. The content is by no means challenging but does require rigorous and careful thinking.",
						  "Get started with writing a compiler as soon as possible. A lot of work.",
						  "Start the work early and be very careful and thorough when you do.",
						  "Depending on how fast and good a coder you are, you might find this course moderately easy or challenging"]
		},
		{
			"Name" : "Introductory Applied Machine Learning",
			"Code" : "INFR10069",
			"CourseSummary" : "Since the early days of AI, researchers have been interested in making computers learn, rather than simply programming them to do tasks. This is the field of machine learning. The main area that will be discussed is supervised learning, which is concerned with learning to predict an output, given inputs. A second area of study is unsupervised learning, where we wish to discover the structure in a set of patterns; there is no output 'teacher signal'.The primary aim of the course is to provide the student with a set of practical tools that can be applied to solve real-world problems in machine learning, coupled with an appropriate, principled approach to formulating a solution.",
			"CourseDescription" : "Introduction to Machine Learning and its Goals. Introduction to Data and Models. Memory based methods. Decision Trees. Error functions, Minimizing Error. Regression, Logistic Regression, Neural Networks. Margin Based Methods: Perceptron, Support Vector Machines. Naïve Bayes. Dimensionality Reduction. Clustering: K-means, Simple Gaussian Mixture Models, Hierarchical Clustering. Boosting Approaches. Model Averaging, Mixtures of Experts. Evaluation of Performance.",
			"Credits" : "20",
			"Level" : "10",
			"Year" : "3",
			"Average" : "67.49",
			"Area" : "Artificial Intelligence",
			"Prerequisites" : [],
			"Feedback" : ["Be prepared to learn on your own and definitely check Coursera for a very similar course. Also do all the labs and coursework in a timely manner and studying for the exam will be a piece of cake",
						  "Definitely a demanding course but exciting and lets you practice all the interesting stuff you learned.",
						  "Is a good introductory course. However, expect to spend a lot of time on the assignments.",
						  "It is a fast paced course. Make sure you know some machine learning before getting into this course",
						  "It's a great practical course for ML."]
		},
		{
			"Name" : "Introduction to Theoretical Computer Science",
			"Code" : "INFR10059",
			"CourseSummary" : "This course introduces the fundamental concepts of the theory of computer science: what does `computing' mean? Are all `computers' basically the same? Can we tell whether our programs are `correct' - and what does `correct' mean, anyway? Can we solve problems in reasonable time, and can we tell whether we can? The course concentrates primarily on conceptual understanding, but adds enough detail to allow students to go on to further courses, and illustrates how the fundamental concepts are reflected throughout the discipline.",
			"CourseDescription" : "The first section of the course asks the question, what does it mean to compute? We start with very simple abstract computers, and argue they can do everything real computers can do. We then ask, can we solve every computational question? The answer, which which Turing shocked the mathematicians of the 1930s, is no, with a remarkably easy but beautiful argument (introduced at the end of Inf2A). We then explore some different, but always equivalent, ways of defining a computer. We finish the section by asking how we can compare the difficulty of different problems, and introduce the idea of reduction as a way of compiling one problem into another. Technically, this covers register machines, undecidability, Turing machines, and reductions.  The second section thinks about how hard it is to solve solvable problems, leading to one of the most important problems in all mathematics, and the foundation of internet security. We start by reprising Inf2A analysis of algorithms, and then discuss the idea of classifying problems as `tractable' (easy) or `intractable' (hard). We find that the idea of algorithms whose running time grows polynomially in the problem size is a good mathematical definition of `tractable', though not always a practical one. After making this more precise, we ask what happens if we're allowed to just check all the possible answers in parallel - does this give us more problem-solving power? The question is made precise by the concept of NP, and we show that there are hardest such problems, such as the famous Travelling Salesman. Although the question is easy to ask, nobody knows how to answer it. This is P = NP - if you can solve it, you win a million dollars, and fame for as long as civilization lasts. So far, NP problems are very hard to solve in practice, so we discuss how to deal with them. We finish the section by talking about much harder problems still. Technically, this section covers P, NP, hardness and completeness, Cook's Theorem, P = NP, and the complexity hierarchy above NP.  The third section considers a different way of seeing computation. Haskell needn't be seen as a programming language, it can be the computer itself. We'll show how the lambda-calculus (on which Haskell is based) can do all the computing our other models could. Unlike the register and Turing machines, lambda-calculus lets us easily use types, which get rid of a whole class of possible bugs from our programs. This typing underlies almost all modern languages, including such recent things as generics in Java. We'll show how we can decide whether a lambda program is correct in its type, and even how we can do the typing automatically, instead of making the programmer do it. It turns out that this latter is one of those weird problems that is ridiculously hard in theory, but perfectly doable in practice, which bring us back to the complexity hierarchies of the second section. Technically, this covers lambda-calculus, simple types, polymorphism, type checking and type inference.  Register and Turing machines, undecidability, reductions. Intractability and growth rates. P and poly-time reductions, NP, hardness and completeness. Cook's Theorem. P = NP. Beyond NP. Lambda-calculus, through to simply-typed lambda, type safety, polymorphism, type inference and Hindley-Milner.",
			"Credits" : "10",
			"Level" : "10",
			"Year" : "3",
			"Average" : "72.74",
			"Area" : "Theory of Computation",
			"Prerequisites" : [],
			"Feedback" : ["Do the coursework as the semester progresses - it makes it a lot more manageable, and the questions roughly correspond to material taught each week",
						  "Hard work if you're not already proficient at this type of thing but worth it.",
						  "Mathematics and proofs heavy, but extremely well explained so that even if you're struggling you're unlikely to fall behind, would recommend.",
						  "Read the notes! They are good! And do the coursework as soon as you can!"]
		},
		{
			"Name" : "Professional Issues",
			"Code" : "INFR10022",
			"CourseSummary" : "There are many commercial, engineering and professional issues, complementary to the necessary scientific knowledge and technical skills, that impinge on the work of the computing professional. The Professional Issues course aims to provide a general awareness of these issues and to cover some of them in depth. The course will involve lectures from members of staff and visitors and directed reading.",
			"CourseDescription" : "* Personal Attributes: study skills, personal development, interpersonal skills; employers' views and expectations of graduates; study skills, writing skills, presentation skills. The Computing Profession: professional bodies; codes of conduct and practice. * Social and ethical issues: security, privacy, software ownership * Legal Issues: legal and regulatory frameworks; software contracts and liability; intellectual property, copyright and patents; computer misuse, data protection; health and safety. * Commercial Issues: organisational structures; finance, accounting, audit; resource management. * Computing Projects: design, prototype and product; product development cycle; marketing and market research; project management and team working; change management.  * This course consolidates complements and assesses the students appreciation and understanding of Professional Issues introduced across our curriculum.",
			"Credits" : "10",
			"Level" : "10",
			"Year" : "3",
			"Average" : "68.09",
			"Area" : "Theory and Ethics",
			"Prerequisites" : [],
			"Feedback" : ["Don't", "Not a particularly interesting course but necessary.", "The course is a lot more relevant than you think. So pay attention because the information will come handy in the future.",
						  "You will not want to go to all the lectures because some of them are quite useless (for example teaching you how to spell...) but the guest lectures are refreshing and quite interesting"]
		},
		{
			"Name" : "Software Testing",
			"Code" : "INFR10057",
			"CourseSummary" : "This module is intended to provide in-depth coverage of software testing further to develop the introductory material covered in Informatics 2C - Software Engineering. The goal of the course is to provide students with the skill to select and apply a testing strategy and testing techniques that are appropriate to a particular software system or component. In addition the student will become a capable user of test tools; will be able to assess the effectiveness of their testing activity; and will be able provide evidence to justify their evaluation. The course will be supported by two practical exercises involving the development of appropriate tests and the application of a range of testing tools. This course is based on the IEEE Software Engineering 2004 Software Testing syllabus.",
			"CourseDescription" : "# Testing techniques and principles: Defects vs. failures, equivalence classes, boundary testing. # Types of defects. # Black-box vs. Structural testing. # Testing strategies: Unit testing, integration testing, profiling, test driven development. # State based testing; configuration testing; compatibility testing; web site testing. # Alpha, beta, and acceptance testing. # Coverage criteria. # Test instrumentation and tools. # Developing test plans. # Managing the testing process. # Problem reporting, tracking, and analysis. Relevant QAA Computing Curriculum Sections: Software Engineering",
			"Credits" : "10",
			"Level" : "10",
			"Year" : "3",
			"Average" : "76.62",
			"Area" : "Software Engineering",
			"Prerequisites" : [],
			"Feedback" : ["It's a nice course. Take it if you like. :-)",
						  "Just take, it's useful, quite easy and the exam is open book",
						  "Many of the software testing approaches may seem intuitive and even obvious but I highly recommend taking the course simply to gain the useful confidence that will pay off in any software engineering interview or job.",
						  "This course is worth taking if you are interested in software testing methods and concepts.",
						  "I liked the professor's explanations, and found everything fairly straightforward."]
		},
		{
			"Name": "Advanced Databases",
      		"Code": "INFR11011",
      		"CourseSummary":"This course aims at furthering database systems concepts through adding complexity and a more hands-on approach. In particular, we will focus on supporting multi-dimensional data in a DBMS, query optimisation, query evaluation, transaction processing and concurrency control in both a centralised and a distributed context. In terms of centralised databases, we shall start from single and multi-dimensional indexing methods, move on to join evaluation algorithms, and talk about query opimisation paradigms. We shall then focus on the issues of transaction processing, concurrency control and crash recovery. Finally, we shall revisit the previous issues in a distributed database environment.",
      		"CourseDescription":"This is an overview of what will be covered. The time spent on each part will be adjusted as the course progresses. * B-trees, hash-based indexes, R-trees. * Indexing structures for solid state and main memory. * Query evaluation: sorting and join processing, aggregation * Algorithmic adjustments for flash memory and main-memory systems. * Query optimisation: cost-based query optimisation, dynamic programming, randomised exploration, rule-based optimisation. * Concurrency and recovery: transactions, lock tables, main-memory concurrency control, recovery using the ARIES algorithm. * Parallel databases: parallel query evaluation, parallel and distributed transaction processing. Relevant QAA Computing Curriculum Sections: Databases, Data Structures and Algorithms, Software Engineering",
      		"Credits": "10",
      		"Level": "11",
      		"Year": "4",
      		"Average": "72.23",
      		"Area": "Databases",
      		"Prerequisites": ["Database Systems"],
                  "Feedback": [
                    "Dr Paolo Guagliardo is great at explaining the material clearly. He also always pays attention whether the Media Hopper camera is on. This is really helpful if missed some lectures and also for the revision for the exam since, unfortunately, there are no pdf slides for this course. However, the course material is in alignment with the course book, which also gives nice explanations. Be aware this course is not about manipulating data in database but rather about the implementation of database management system (e.g. how dbms fetches data from a disk or various types of indexing). Coursework covered actual material of the course.",
                    "The lecture explain every knowledge point quite clear.",
                    "The lecturer really seemed to care about the quality of his teaching, and it fully paid off",
                    "The lectures are good.",
                    "Have recommended readings to go along with lectures or course notes as currently the lectures are all done on the board with no lecture slides or anything to reinforce what you have seen in the lectures. Going back through lecture slides is a good way to revise but as there is no slides for this class, you would have to go and rewatch all the lectures which is much more time consuming.",
                    "The lecturer wrote everything on the whiteboard. Although everything he wrote is on the recordings, it would be nice to have some slides. As mentioned above, Dr Paolo Guagliardo had always examples already prepared, so maybe he could make a pdf version of them in advance.",
                    "Would be nice to have an outline of topics covered/ to be covered, with corresponding chapters from the textbook"
                ]
         },
		{
			"Name": "Advanced Topics in Foundations of Databases",
      		"Code": "INFR11122",
      		"CourseSummary":"The course focuses on three central aspects of big data: Volume, Variety and Veracity. It will cover tractability and parallel scalability of querying big data (volume), data models and data interoperability (variety), and foundations of data quality and uncertainty (veracity). It aims to expose students to current research and development in connection with big data theory, and prepare them for conducting research in this emerging area. The course content is dynamic and continuously updated to cover the state-of-the-art in big data theory.",
			"CourseDescription":"* Background: Fundamental challenges introduced by querying big data; the need for revising the classical computational complexity theory in the context of big data; modelling computational costs and communication costs; BD-tractability: the tractability of queries on big data; the challenges to query data residing in multiple sources; the need to study data quality, the other side of big data. * Volume: (1) the feasibility of computing exact query answers in big data within our available resources: parallel scalability, scale independence, techniques for making big data small; (2) approximate query answering: (a) query-driven approximation, envelopes with absolute approximation bounds, (b) data-driven approximation, synopsis-based approximate query answering, and (c) resource-bounded approximate query answering and anytime approximation. * Variety: data can be in different formats, and come from different sources and/or applications. We shall cover: (a) popular data models, including relational, XML, and graph models, and languages for them, and (b) handling queries over data residing in multiple sources, focusing on both virtual and materialized integration, and efficient query answering. * Veracity: big data = data quantity + data quality; (1) central issues of data quality: data consistency, data accuracy, information completeness, data currency (timeliness), entity resolution; (2) improving data quality: consistency query answering, data repairing, certain fixes; (3) knowledge bases as master data, deducing the true values of entities; (4) handling poor quality information, understanding current technologies and their deficiencies, correctness guarantees. Big data is the next frontier for innovation, competition and productivity. This course will cover fundamental issues in connection with three of four big V's in the typical characterization of big data, namely, Volume, Variety and Veracity.",
			"Credits": "10",
      		"Level": "11",
      		"Year": "4",
      		"Average": "70.00",
      		"Area": "Databases",
      		"Prerequisites": ["Database Systems"],
                  "Feedback": ["The lecturer really seemed to care about the quality of his teaching, and it fully paid off",
                    "The lectures are good.",
                    "Have recommended readings to go along with lectures or course notes as currently the lectures are all done on the board with no lecture slides or anything to reinforce what you have seen in the lectures. Going back through lecture slides is a good way to revise but as there is no slides for this class, you would have to go and rewatch all the lectures which is much more time consuming.",
                    "The lecturer wrote everything on the whiteboard. Although everything he wrote is on the recordings, it would be nice to have some slides. As mentioned above, Dr Paolo Guagliardo had always examples already prepared, so maybe he could make a pdf version of them in advance.",
                    "Would be nice to have an outline of topics covered/ to be covered, with corresponding chapters from the textbook"
                ]
         },
		{
			"Name": "Usable Security and Privacy",
      		"Code": "INFR11158",
      		"CourseSummary":"Humans are a vital component of secure and private systems, they are also one of the most expensive components and the most challenging to reason about. In this course, students will learn about how to create systems that are usable while still fulfilling their primary security or privacy mission. Students will also learn about research topics such as designing user studies to critically evaluate interfaces and reading academic papers to create an academically-informed view of the topic.",
			"CourseDescription":"- Introduction: History and overview of the Usable Security and Privacy research area including the transition from blaming users to treating them as valued components of a secure system.- Study design: Security and privacy activities tend to be secondary tasks. The student will learn how to design and analyze usability studies that are common in security and privacy such as targeting secondary tasks or using some deception. - Privacy: Basic overview of the definitions of privacy as well as some of the legal and social aspects of it. Analysis of common privacy issues and how they are expressed through user interaction with systems. - Security: Overview of common security technologies and how they are impacted by usability. In- depth look at select topics such as password construction and management. - Ethics: Discussion of ethics, particularly around research in topics in security and privacy where participants can be particularly vulnerable.",
			"Credits": "10",
      		"Level": "11",
      		"Year": "4",
      		"Average": "75.00",
      		"Area": "Security and Cryptography",
      		"Prerequisites": ["Computer Security"],
                  "Feedback": []
		},

		{
			"Name": "Accelerated Natural Language Processing ",
      		"Code": "INFR11125",
      		"CourseSummary":"The course will synthesize ideas from linguistics and computer science to provide students with a fast-paced introduction to the field of natural language processing. The course will cover the most widely-used theoretical and computational models of language, including both statistical and nonstatistical approaches. The course will familiarize students with a wide range of linguistic phenomena with the aim of appreciating the complexity, but also the systematic behaviour of natural languages like English, the pervasiveness of ambiguity, and how this presents challenges in natural language processing. In addition, the course introduce the most important algorithms and data structures that are commonly used to solve many NLP problems. The course will cover formal models for representing and analyzing the syntax and semantics of words, sentences, and discourse. Students will learn how to analyse sentences algorithmically, using hand-crafted and automatically induced treebank grammars, and how to build interpretable semantic representations. The course will also cover a number of standard models and algorithms that are used throughout language processing. Examples include n-gram and Hidden Markov Models, the EM algorithm, and dynamic programming algorithms such as chart parsing.",
			"CourseDescription":"Part I: Words * Inflectional and derivational morphology * Finite state methods and Regular expressions * Word Classes and Parts of speech * Sequence Models (n-gram and Hidden Markov models, smoothing) * The Viterbi algorithm, Forward Backward, EM Part II: Syntax * Syntactic Concepts (e.g., constituency, subcategorisation, bounded and unbounded dependencies, feature representations) * Analysis in CFG - Greedy algorithms---Shift-reduce parsing * Divide-and-conquer algorithms---CKY * Chart parsing * Lexicalised grammar formalisms (e.g., TAG, CCG, dependency grammar) * Statistical parsing (PCFGs, dependency parsing) Part III: Semantics, Discourse, Dialogue and Applications * logical semantics and compositionality * Semantic derivations in grammar * Lexical Semantics (e.g., word senses, semantic roles) * Discourse and dialogue (e.g., anaphora, speech acts) * Text classification and sentiment analysis * Other applications (e.g., machine translation, question answering) Methodological topics, interspersed throughout: * Issues in annotation and evaluation * Machine learning approaches (e.g., Maximum Entropy models, neural networks)",
			"Credits": "10",
      		"Level": "11",
      		"Year": "4",
      		"Average": "22.00",
      		"Area": "Artificial Intelligence",
      		"Prerequisites": [],
                  "Feedback": []}
		]
}